# 语法分析模块设计

## 一、编码前的设计方案

语法分析模块位于编译器前端的核心位置，其主要职责是依据 SysY 语言文法，对词法分析阶段产生的 Token 流进行结构化解析，并构建抽象语法树（AST），为后续语义分析与中间代码生成提供语法基础。

### 1. 设计目标

本模块的设计目标包括：

* 严格遵循 SysY 语言文法规则，构建层次清晰、结构完整的 AST；
* 保证 AST 节点类型与文法产生式之间具有良好的对应关系；
* 在语法错误发生时具备**基本的错误恢复能力**，避免因单一错误导致分析过程提前终止。

### 2. 解析策略选择

语法分析采用**递归下降（Recursive Descent）**方法，并配合**单符号前瞻（Single-token Lookahead）**机制实现。
该方案具有实现直观、调试友好、与手写编译器项目契合度高等优点，适合 SysY 语言规模与复杂度。

在 AST 设计上，遵循“**一产生式一节点类型**”的原则，使抽象语法树结构能够直接反映文法层级，有利于后续基于 Visitor 模式的遍历与处理。

### 3. 语法错误恢复策略

为提升编译器的健壮性，在设计阶段即引入了简化的错误恢复机制，主要针对常见语法错误类型：

* 分号（`;`）缺失
* 右小括号（`)`）缺失
* 右中括号（`]`）缺失

当检测到上述错误时，分析器会：

1. 记录并报告当前语法错误；
2. 跳过 Token 流，直至到达同步点（通常为 `;` 或 `}`）；
3. 恢复分析流程，继续构建后续 AST 结构。

该策略在实现成本可控的前提下，有效提高了错误容忍能力。

### 4. 对外接口设计

语法分析模块对外提供统一入口函数：

```cpp
Parser::parse()
```

该接口负责驱动完整的语法分析过程，并在分析成功后返回语法树根节点 `CompUnit`，作为前端阶段的最终输出。

---

## 二、编码完成后的实现调整与改进

在实际编码与调试过程中，针对部分文法歧义与工程实现需求，对初始设计进行了必要的扩展与细化。

### 1. 前瞻与回退机制的引入

虽然最初设计基于单符号前瞻，但在具体实现 SysY 文法时，发现以下结构存在歧义：

* 左值表达式（`LVal`）
* 函数调用（`FuncCall`）

二者在前缀形式上高度相似，均以标识符开头。为正确区分这两类语法结构，实际实现中引入了：

* `lookahead`：用于提前查看后续 Token；
* `ungetToken`：在必要时将 Token 回退至输入流。

该机制在保持递归下降整体框架不变的前提下，有效解决了文法歧义问题。

### 2. 递归结构的复用与接口重载

为避免在处理 `LVal` 与相关语法结构时重复读取 Token，解析器中增加了形如：

```cpp
parseXxx(lval)
```

的重载解析路径，使得在已确定部分语法前缀的情况下，能够直接复用既有递归解析逻辑。
这一设计在不破坏原有解析流程的前提下，提高了代码复用率并减少了状态管理复杂度。

### 3. 错误恢复策略的工程化实现

在具体实现中，错误恢复逻辑被集中封装为 `skipUntilSemicn` 等辅助函数。当解析过程中遇到与预期 Token 不匹配的情况时，分析器会：

* 主动生成错误信息；
* 跳过 Token 流直至遇到同步符号；
* 继续执行后续解析。

该方式使错误处理逻辑更加集中、可控，也便于后续扩展为更复杂的恢复策略。

### 4. 语法树输出支持

为满足课程作业与调试需求，在解析器中引入可选的输出流 `out_`，用于在语法分析阶段打印 AST 节点标签。
该功能仅用于辅助验证与结果展示，不影响语法树的实际构建与后续阶段使用。

---

## 三、小结

本语法分析模块在整体设计上遵循了**递归下降解析的经典实现范式**，并在实践中针对文法歧义与工程可维护性进行了适度增强。
通过引入有限前瞻、Token 回退机制及结构化的错误恢复策略，在保证实现复杂度可控的前提下，实现了功能完整、鲁棒性较好的语法分析器。