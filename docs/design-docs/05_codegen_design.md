# 代码生成模块设计

## 一、编码前的设计规划

代码生成模块承担着将前端分析结果转化为可执行形式的核心职责，是连接语义分析阶段与目标体系结构的关键环节。本项目在设计阶段即明确采用“**自定义 LLVM 风格 IR + 直接面向 MIPS 的后端生成**”的总体路线，以兼顾结构清晰性与实现复杂度的可控性。

### 1. 设计目标

代码生成模块的主要目标包括：

* 构建一套结构完备、语义明确的 **LLVM 风格中间表示（IR）**；
* 支持 IR 的文本化输出，便于调试、验证与分析；
* 在 IR 基础上生成符合 MIPS 架构规范的汇编代码，作为最终可执行结果。

### 2. 中间表示（IR）结构设计

自定义 IR 在整体结构上对齐 LLVM 的核心抽象模型，主要包含以下实体：

* **Module**：表示一个完整的编译单元；
* **Function**：函数级中间表示，包含参数列表与基本块集合；
* **BasicBlock**：基本块，作为控制流图（CFG）的节点；
* **Instruction**：指令级表示，采用 SSA 风格；
* **Type**：类型系统，用于描述值的静态类型；
* **Value**：统一的值抽象，表示指令结果、常量或参数。

该结构设计为后续的优化与目标代码生成提供了稳定、清晰的操作对象。

### 3. IR 生成策略

IR 生成采用基于 AST 的 Visitor 模式，在遍历语法树的过程中逐步构建中间表示，主要策略包括：

* **SSA 风格值生成**
  每一个表达式或计算结果对应一个新的 SSA 值，显式表示数据依赖关系。
* **数组访问与地址计算**
  使用 GEP（GetElementPtr）指令表达数组元素地址计算，保持与 LLVM IR 语义的一致性。
* **控制流建模**
  通过 `BasicBlock` 组织程序的控制流结构，并使用条件分支（Branch）与无条件跳转（Jump）指令显式构建控制流图（CFG）。

### 4. 后端输出设计

在后端实现上，项目采用双输出通道：

* **IR 文本输出**
  由 `AsmWriter` 负责，将 IR 结构序列化为可读的 LLVM 风格文本格式；
* **MIPS 汇编输出**
  由 `MipsPrinter` 直接基于 IR 结构生成目标汇编代码。

该设计避免了在早期阶段引入过多后端复杂性，同时保留了对 IR 的完整可观察性。

---

## 二、编码完成后的实现调整与优化

在具体实现过程中，结合实际运行效果与中间代码规模控制的需求，对原有设计进行了若干工程层面的增强。

### 1. 局部公共子表达式消除（Local CSE）

在 AST Visitor 中引入了**局部公共子表达式消除（Common Subexpression Elimination, CSE）**机制：

* 对已生成的中间结果建立缓存表；
* 在生成新指令前检查是否存在等价的已计算表达式；
* 若命中缓存，则直接复用已有 SSA 值，避免重复指令生成。

该策略在不增加额外分析 Pass 的情况下，有效减少了冗余计算。

### 2. Load Cache 与死代码消除协同

针对频繁出现的内存加载操作，实现中引入了 **load cache** 机制，用于缓存近期加载结果，降低不必要的重复 `load` 指令数量。

同时，通过：

* 在 IR 层面运行 `runDCE`（Dead Code Elimination）；
* 与 CSE 缓存表协同工作，

进一步压缩了中间代码规模，提高了生成 IR 的整体质量。

### 3. 简化的后端生成路径

在 MIPS 代码生成阶段，后端直接遍历 IR 中的 `BasicBlock` 与 `Instruction` 结构生成目标汇编指令，**未额外引入独立的机器级 IR（Machine IR）层**。
该取舍在保证功能正确性的前提下：

* 显著降低了后端实现复杂度；
* 使 IR 到汇编的映射关系更加直观；
* 非常适合教学型或实验型编译器项目。

---

## 三、小结

本代码生成模块以 LLVM 的中间表示思想为设计参考，通过自定义 IR 实现前后端解耦，并在工程实践中引入轻量级优化（CSE、DCE、load cache）以提升中间代码质量。在后端阶段采用直接从 IR 到 MIPS 的生成路径，在复杂度、可维护性与实现成本之间取得了合理平衡。
