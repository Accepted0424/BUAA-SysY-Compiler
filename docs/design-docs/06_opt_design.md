# 代码优化模块设计

## 一、编码前的设计规划

代码优化模块位于中间表示（IR）处理阶段，其目标并非追求激进或高度复杂的优化效果，而是在**保证语义正确性不受影响**的前提下，引入一组**轻量、可实现且收益明确的优化策略**，以改善中间代码质量并为后端代码生成创造更有利的条件。

### 1. 设计目标

本模块在设计阶段明确了以下原则：

* 所有优化均作用于 **IR 层面**，与目标架构无关；
* 优化过程必须保持程序语义等价，不引入行为变化；
* 优化实现应结构清晰、易于验证，避免过度复杂的分析；
* 以中小规模 IR 为主要应用场景，强调实用性而非极致性能。

### 2. Pass 类型与规划

在初始规划中，优化 Pass 主要包括以下三类：

* **常量折叠（Constant Folding）**
  在编译期对可确定的常量表达式进行求值，减少运行期计算。
* **死代码消除（Dead Code Elimination, DCE）**
  删除对程序输出无影响的冗余指令与无用内存操作。
* **控制流图化简（CFG Simplification）**
  对控制流结构进行重写，消除多余分支与不可达代码。

### 3. Pass 调度策略

在调度层面，采用 **Function 级别的 Pass 执行模型**。
各 Pass 在单个函数内部按既定顺序执行，并通过**多轮迭代**反复应用，直至 IR 不再发生变化，从而保证不同优化之间能够相互促进并达到稳定状态。

---

## 二、编码完成后的实现与细化

在具体实现过程中，对原有设计进行了工程化落地，并在 Pass 管理与执行策略上进一步完善。

### 1. PassManager 的实现与执行模型

项目实现了统一的 `PassManager`，其主要职责包括：

* 按函数粒度遍历 IR；
* 在每个函数上顺序执行已注册的优化 Pass；
* 在 Pass 执行后检测 IR 是否发生变化；
* 若发生变化，则触发下一轮迭代，直至达到不动点（Fixpoint）。

该机制在实现复杂度可控的前提下，实现了与 LLVM Pass Pipeline 类似的迭代优化效果。

### 2. 已实现的优化 Pass

当前系统中实际实现并启用的优化 Pass 包括：

#### （1）ConstantFoldPass

该 Pass 负责在 IR 层面对常量表达式进行求值与简化，具体包括：

* 常量算术运算的直接折叠；
* 简单代数恒等式的化简（如乘零、加零等）；
* 将计算结果替换为常量值，减少指令数量。

#### （2）DcePass（死代码消除）

死代码消除 Pass 主要关注以下无效指令与冗余操作：

* 未被使用的 `alloca` 与 `store` 指令；
* 无副作用且结果未被引用的计算指令；
* 在控制流层面不可达的指令序列。

通过系统性清理这些无用指令，显著降低了 IR 的规模与复杂度。

#### （3）CfgSimplifyPass

控制流图化简 Pass 针对 IR 中的控制流结构进行重写，主要优化包括：

* 对条件为常量的分支进行静态跳转；
* 删除不可达的基本块；
* 合并仅包含空跳转的中间基本块，减少 CFG 节点数量。

该 Pass 有助于生成更加紧凑、直观的控制流结构。

### 3. 默认 Pass 配置与统一入口

所有上述优化 Pass 均在 `addDefaultPasses` 接口中进行集中注册，并作为**默认优化流水线**启用。
通过该统一入口，编译流程中的 IR 在进入后端生成阶段之前，能够自动接受一套一致、可复现的优化处理。

---

## 三、小结

本代码优化模块在设计上坚持“**轻量、可靠、可验证**”的原则，通过 Function 级别的 PassManager 与多轮迭代机制，实现了常量折叠、死代码消除与控制流化简等核心优化。
这些优化在显著提升中间代码质量的同时，并未引入额外的复杂分析或架构依赖，为后续 MIPS 代码生成阶段提供了更加简洁、规范的 IR 输入。